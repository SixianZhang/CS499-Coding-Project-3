% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NNetEarlyStoppingCV.R
\name{NNetEarlyStoppingCV}
\alias{NNetEarlyStoppingCV}
\title{Neral Network algorithm using cross validation}
\usage{
NNetEarlyStoppingCV(X.mat, y.vec, fold.vec = sample(rep(1:n.folds, l =
  length(y.vec))), max.iterations, step.size, n.hidden.units,
  n.folds = 4L)
}
\arguments{
\item{X.mat}{numeric feature matrix of size [n_observations x n_features].}

\item{y.vec}{numeric label vector of length n_observations.}

\item{fold.vec}{numeric fold vector of length n_observations.}

\item{max.iterations}{integer scalar greater than 1.}

\item{step.size}{numeric positive scalar.}

\item{n.hidden.units}{number of hidden units, greater than or equal to 1.}

\item{n.folds}{positive integer scalar, numbers of folds, default is 4}
}
\value{
result.list with named elements:
pred.mat, n_observations x max.iterations matrix of predicted values.
V.mat final weight matrix (n_features+1 x n.hidden.units).
w.vec final weight vector (n.hidden.units+1).
mean.validation.loss.vec mean loss for all validation sets.
mean.train.loss.vec mean loss for all training sets.
selected steps best step size selected corresponding to the minimum mean validation loss.
predict(testX.mat) a function that takes a test features matrix and returns a vector of predictions.
}
\description{
This neral network algorithm has one output and one hidden layer, and uses cross validation to find the best step
size corresponding to the max.iterations.
}
\examples{
#Binary Classification:
library(NeuralNetwork)
data(spam, package = "ElemStatLearn")
X.mat = as.matrix(spam[, 1:57])
y.vec  = ifelse(spam$spam == "spam", 1, -1)
result.list <- NNetEarlyStoppingCV(X.mat, y.vec, max.iterations = 30L, step.size = 0.02, 
                                   n.hidden.units = 100L, n.folds = 5L)
y.test <- ifelse(result.list$predict(X.mat[1:3,]) > 0.5, 1, -1)

#Linear Regression

library(NeuralNetwork)
data(ozone, package = "ElemStatLearn")
X.mat <- as.matrix(ozone[, -1])
y.vec <- as.vector(ozone[, 1])
result.list <- NNetEarlyStoppingCV(X.mat, y.vec, max.iterations = 30L, step.size = 0.02, 
                                   n.hidden.units = 100L, n.folds = 5L)
y.test <- result.list$predict(X.mat[1:3,])
}
